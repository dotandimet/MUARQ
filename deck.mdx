import {
  CodeSurferLayout,
  CodeSurferColumnLayout,
} from "code-surfer";
import "prismjs/components/prism-perl";
export { nightOwl as theme } from "code-surfer";
import { Appear, Image, Notes } from "mdx-deck";

## Mojo::UserAgent::Role::Queued

A module name so long I had to drop a
heading level to fit it in.

---

<CodeSurferLayout>

```perl

package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};

```
```perl 4,5[7:11],7[21:25],10[12:16] subtitle="Override Mojo::UserAgent->start()"

package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};

```
```perl 5[26:28],6[7:9],7[46:48] subtitle="queue only if passed a callback (non-blocking call)" 

package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};

```
```perl 7[20:49] subtitle="queue only if passed a callback (non-blocking call)" 

package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};

```
```perl subtitle="this is _enqueue"

package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};

use Scalar::Util 'weaken';
sub _enqueue {
  my ($self, $start, $job) = @_;
  $self->{'jobs'} ||= [];
  push @{$self->{'jobs'}}, $job;
  unless ($self->{'timer'}) {
      weaken $self;
      weaken $start;
      $self->{'timer'} = Mojo::IOLoop->recurring(0 => sub { $self->_process($start); });
  }
}
```
```perl 19,22 subtitle="A recurring() timer is a bit of a sledgehammer"

package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};

use Scalar::Util 'weaken';
sub _enqueue {
  my ($self, $start, $job) = @_;
  $self->{'jobs'} ||= [];
  push @{$self->{'jobs'}}, $job;
  unless ($self->{'timer'}) {
      weaken $self;
      weaken $start;
      $self->{'timer'} = Mojo::IOLoop->recurring(0 => sub { $self->_process($start); });
  }
}

```
```perl subtitle="and we need to cleanup after it"

package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};

use Scalar::Util 'weaken';
sub _enqueue {
  my ($self, $start, $job) = @_;
  $self->{'jobs'} ||= [];
  push @{$self->{'jobs'}}, $job;
  unless ($self->{'timer'}) {
      weaken $self;
      weaken $start;
      $self->{'timer'} = Mojo::IOLoop->recurring(0 => sub { $self->_process($start); });
  }
}

sub _stop_queue {
  my ($self) = @_;
  if ($self->{'timer'}) {
    Mojo::IOLoop->remove($self->{'timer'});
    $self->{'timer'} = undef;
  }
  return $self;
}

before DESTROY => sub {
  my ($self) = shift;
  $self->_stop_queue();
};


```
```perl subtitle="and here is _process() itself"

has max_active => sub { shift->max_connections };

sub _process {
  my ($self, $original_start) = @_;
  state $start //= $original_start;
  state $active //= 0;
  # we have jobs and can run them:
  while ($active < $self->max_active
    and my $job = shift @{$self->{'jobs'}})
  {
    my ($tx, $cb) = ($job->{tx}, $job->{cb});
    $active++;
    $start->( $self, $tx,
              sub {
                    my ($ua, $tx) = @_;
                    $active--;
                    $cb->($ua, $tx);
                    $ua->_process();
        });
  }
  if (scalar @{$self->{'jobs'}} == 0 && $active == 0) {
    $self->emit('stop_queue');
    $self->_stop_queue();    # the timer shouldn't run STAM.
  }
}

```
```perl 1,6,8:9,12,16 subtitle="limit the number of active jobs"

has max_active => sub { shift->max_connections };

sub _process {
  my ($self, $original_start) = @_;
  state $start //= $original_start;
  state $active //= 0;
  # we have jobs and can run them:
  while ($active < $self->max_active
    and my $job = shift @{$self->{'jobs'}})
  {
    my ($tx, $cb) = ($job->{tx}, $job->{cb});
    $active++;
    $start->( $self, $tx,
              sub {
                    my ($ua, $tx) = @_;
                    $active--;
                    $cb->($ua, $tx);
                    $ua->_process();
        });
  }
  if (scalar @{$self->{'jobs'}} == 0 && $active == 0) {
    $self->emit('stop_queue');
    $self->_stop_queue();    # the timer shouldn't run STAM.
  }
}

```
```perl 13:19 subtitle="wrap the original callback to invoke itself"

has max_active => sub { shift->max_connections };

sub _process {
  my ($self, $original_start) = @_;
  state $start //= $original_start;
  state $active //= 0;
  # we have jobs and can run them:
  while ($active < $self->max_active
    and my $job = shift @{$self->{'jobs'}})
  {
    my ($tx, $cb) = ($job->{tx}, $job->{cb});
    $active++;
    $start->( $self, $tx,
              sub {
                    my ($ua, $tx) = @_;
                    $active--;
                    $cb->($ua, $tx);
                    $ua->_process();
        });
  }
  if (scalar @{$self->{'jobs'}} == 0 && $active == 0) {
    $self->emit('stop_queue');
    $self->_stop_queue();    # the timer shouldn't run STAM.
  }
}

```
```perl 21:24 subtitle="cleanup when queue is empty"

has max_active => sub { shift->max_connections };

sub _process {
  my ($self, $original_start) = @_;
  state $start //= $original_start;
  state $active //= 0;
  # we have jobs and can run them:
  while ($active < $self->max_active
    and my $job = shift @{$self->{'jobs'}})
  {
    my ($tx, $cb) = ($job->{tx}, $job->{cb});
    $active++;
    $start->( $self, $tx,
              sub {
                    my ($ua, $tx) = @_;
                    $active--;
                    $cb->($ua, $tx);
                    $ua->_process();
        });
  }
  if (scalar @{$self->{'jobs'}} == 0 && $active == 0) {
    $self->emit('stop_queue');
    $self->_stop_queue();    # the timer shouldn't run STAM.
  }
}

```
```perl 13:14 subtitle="Improvement: use the finish event of Mojo::Transaction for cleanup"

has max_active => sub { shift->max_connections };

sub _process {
  my ($self, $original_start) = @_;
  state $start //= $original_start;
  state $active //= 0;
  # we have jobs and can run them:
  while ($active < $self->max_active
    and my $job = shift @{$self->{'jobs'}})
  {
    my ($tx, $cb) = ($job->{tx}, $job->{cb});
    $active++;
    $tx->on(finish => sub { $active--; $self->_process() });
    $start->( $self, $tx, $cb );
  }
  if (scalar @{$self->{'jobs'}} == 0 && $active == 0) {
    $self->emit('stop_queue');
    $self->_stop_queue();    # the timer shouldn't run STAM.
  }
}

```
```perl subtitle="which lets us get rid of the timer"

package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';
use Scalar::Util 'weaken';

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};

sub _enqueue {
  my ($self, $start, $job) = @_;
  $self->{'jobs'} ||= [];
  push @{$self->{'jobs'}}, $job;
  unless ($self->{'timer'}) {
      weaken $self;
      weaken $start;
      $self->{'timer'} = Mojo::IOLoop->recurring(0 => sub { $self->_process($start); });
  }
}

sub _stop_queue {
  my ($self) = @_;
  if ($self->{'timer'}) {
    Mojo::IOLoop->remove($self->{'timer'});
    $self->{'timer'} = undef;
  }
  return $self;
}

before DESTROY => sub {
  my ($self) = shift;
  $self->_stop_queue();
};


```
```perl subtitle="win!"

package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';
use Scalar::Util 'weaken';

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};

sub _enqueue {
  my ($self, $start, $job) = @_;
  $self->{'jobs'} ||= [];
  push @{$self->{'jobs'}}, $job;
  $self->_process($start);
  }
}


```

</CodeSurferLayout>

---

# Winning?

---

<CodeSurferLayout>

```perl

my $ua = Mojo::UserAgent->new->with_roles('+Queued');

$ua->max_active(5); # process up to 5 requests at a time
   for my $url (@big_list_of_urls) {
   $ua->get($url, sub {
           my ($ua, $tx) = @_;
           if ($tx->success) {
               say "Page at $url is titled: ",
                 $tx->res->dom->at('title')->text;
           }
          });
  };
  # works with promises, too:
 my @p = map {
   $ua->get_p($_)->then(sub { pop->res->dom->at('title')->text })
     ->catch(sub { say "Error: ", @_ })
 } @big_list_of_urls;
  Mojo::Promise->all(@p)->wait;
```

</CodeSurferLayout>

---

# BUGS

---

<video autoplay muted loop controls>
<source src="process.webm" type="video/webm" />
<source src="https://raw.githubusercontent.com/dotandimet/MUARQ/master/process.webm" type="video/webm" />
oh noes, no video
</video>

---
<CodeSurferLayout>

```

my $ua = Mojo::UserAgent->new->with_roles('+Queued');


```
```perl 1:4

my $ua = Mojo::UserAgent->new->with_roles('+Queued');
$ua->get(..., sub {

})


```
```perl 1:4

my $ua = Mojo::UserAgent->new->with_roles('+Queued');
$ua->get(..., sub {
 # 💣💣💣
})


```
```perl 1:6

my $ua = Mojo::UserAgent->new->with_roles('+Queued');
$ua->get(..., sub {
 # 💣💣💣
})

# 😭😭😭

```
</CodeSurferLayout>

---

# Bug 1: "private" methods
  * There are no private methods in Perl
  * All subs are package globals

---

# Solution:

    package MyPkg;

    my $var;
    $var = sub { ... };

---

<CodeSurferLayout>

```perl subtitle="private hack"

# Private methods:

my $_process_queue;
$_process_queue = sub {
  my ($self, $start) = @_;
  ...
    $tx->on(finish => sub { $active--; $self->$_process_queue() });
  ...
  }
};

my $_enqueue = sub {
  my ($self, $start, $job) = @_;
  ...
  $self->$_process_queue($start);
};


```
```perl 4,7[23:27,47:61,65],15[10:24] title="Memory leak!" subtitle="closure closes over reference to sub"

# Private methods:

my $_process_queue;
$_process_queue = sub {
  my ($self, $start) = @_;
  ...
    $tx->on(finish => sub { $active--; $self->$_process_queue() });
  ...
};

my $_enqueue = sub {
  my ($self, $start, $job) = @_;
  ...
  $self->$_process_queue($start);
};


```
```perl 4,5,7[47:61],15[10:24] title="Memory Leak" subtitle="workaround: pass reference to sub as parameter"
# Private methods:

my $_process_queue;
$_process_queue = sub {
  my ($self, $start, $this_sub) = @_;
  ...
    $tx->on(finish => sub { $active--; $self->$this_sub() });
  ...
};

my $_enqueue = sub {
  my ($self, $start, $job) = @_;
  ...
  $self->$_process_queue($start, $_process_queue);
};


```
</CodeSurferLayout>

---

# Nice?
## No, gross

---

# Let's hide all this mess in a seperate class

---

<CodeSurferLayout>

```perl
package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';
use Scalar::Util 'weaken';

our $VERSION = "1.01";

has max_active => sub { shift->max_connections };

# Private methods:

my $_process_queue = sub {
  my ($self, $original_start, $ref_to_this_sub) = @_;
  state $start //= $original_start;
  state $active //= 0;
  # we have jobs and can run them:
  while ($active < $self->max_active
    and my $job = shift @{$self->{'jobs'}})
  {
    my ($tx, $cb) = ($job->{tx}, $job->{cb});
    $active++;
    weaken $self;
    $tx->on(finish => sub { $active--; $self->$ref_to_this_sub() });
    $start->( $self, $tx, $cb );
  }
  if (scalar @{$self->{'jobs'}} == 0 && $active == 0) {
    $self->emit('queue_empty');
  }
};

my $_enqueue = sub {
  my ($self, $original_start, $job) = @_;
  $self->{'jobs'} ||= [];
  push @{$self->{'jobs'}}, $job;
  $self->$_process_queue($original_start, $_process_queue);
};


around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  if ($cb) {
    $self->$_enqueue($orig, {tx => $tx, cb => $cb});
  }
  else {
    return $orig->($self, $tx); # Blocking calls skip the queue
  }
};


```
```perl
package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';
use Scalar::Util 'weaken';

our $VERSION = "1.10";
use Mojo::UserAgent::Role::Queued::Queue;

has max_active => sub { shift->max_connections };

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  state $queue //= Mojo::UserAgent::Role::Queued::Queue->new(
    max_active => $self->max_active,
    callback   => sub { $self->$orig(@_); }
  );
  if ($cb) {
    $tx->on(finish => sub { $queue->tx_finish(); });
    $queue->on( queue_empty => sub { $self->emit('queue_empty') });
    $queue->enqueue([$tx, $cb]);
  }
  else {
    return $orig->($self, $tx);    # Blocking calls skip the queue
  }
};

```

```perl
package Mojo::UserAgent::Role::Queued::Queue;

use strict;
use warnings;

use Mojo::Base 'Mojo::EventEmitter';

has jobs => sub { [] };
has active => 0;
has max_active => 4;
has callback => sub { return sub { die "No Method set!"; } };


sub process {
   my ($self) = @_;
  # we have jobs and can run them:
  while ($self->active < $self->max_active
    and my $job = shift @{$self->jobs})
  {
    $self->active($self->active + 1);
    $self->callback->( @$job );
  }
  if (scalar @{$self->jobs} == 0 && $self->active == 0) {
    $self->emit('queue_empty');
  }
}

sub tx_finish {
    my ($self) = @_;
    $self->active($self->active - 1);
    $self->process();
}

sub enqueue {
    my ($self, $job) = @_;
    push @{$self->jobs}, $job;
    $self->process();
}

```

</CodeSurferLayout>

---
# Bug 3
## Singleton

---

### 2018-09-11T11:34:01 [tyldis]
Dang it, it's Mojo::UserAgent::Role::Queued causing me headaches...
Seems to be some scoping issue

---

### 2018-09-11T11:42:25 [batman]
tyldis: I don't get how that module can work at all :(
https://metacpan.org/source/DOTAN/Mojo-UserAgent-Role-Queued-1.10/lib/Mojo/UserAgent/Role/Queued.pm#L12

---

<CodeSurferLayout>

```perl 12:14
package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';
use Scalar::Util 'weaken';

our $VERSION = "1.10";
use Mojo::UserAgent::Role::Queued::Queue;

has max_active => sub { shift->max_connections };

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  state $queue //= Mojo::UserAgent::Role::Queued::Queue->new(
    max_active => $self->max_active,
    callback   => sub { $self->$orig(@_); }
  );
  if ($cb) {
    $tx->on(finish => sub { $queue->tx_finish(); });
    $queue->on( queue_empty => sub { $self->emit('queue_empty') });
    $queue->enqueue([$tx, $cb]);
  }
  else {
    return $orig->($self, $tx);    # Blocking calls skip the queue
  }
};

```

</CodeSurferLayout>

---

### 2018-09-11T11:45:05 [batman]
tyldis: just to elaborate... What I don't understand is that the "callback" inside the
state variable closes over $self, so how is it supposed to work correctly if you have many instances of Mojo::UserAgent?

---

### 2018-09-11T11:45:08 [batman]
dotan_convos: ^

---

### 2018-09-11T11:50:26 [sri]
batman: yea, that's definitely borked
### 2018-09-11T11:51:05 [sri]
prolly wasn't tested with more than one ua

---

# 😭 ??? 😭

---

# MORE than one ? 😳 🤯 🤔

---

# FYI

* state $var makes singletons (global var for the process)

---

<CodeSurferLayout>

```perl
package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';
use Scalar::Util 'weaken';

our $VERSION = "1.10";
use Mojo::UserAgent::Role::Queued::Queue;

has max_active => sub { shift->max_connections };

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  state $queue //= Mojo::UserAgent::Role::Queued::Queue->new(
    max_active => $self->max_active,
    callback   => sub { $self->$orig(@_); }
  );
  if ($cb) {
    $tx->on(finish => sub { $queue->tx_finish(); });
    $queue->on( queue_empty => sub { $self->emit('queue_empty') });
    $queue->enqueue([$tx, $cb]);
  }
  else {
    return $orig->($self, $tx);    # Blocking calls skip the queue
  }
};

```

```perl
package Mojo::UserAgent::Role::Queued;
use Mojo::Base '-role';

our $VERSION = "1.11";
use Mojo::UserAgent::Role::Queued::Queue;

has max_active => sub { shift->max_connections };

has queue => sub {
  Mojo::UserAgent::Role::Queued::Queue->new(max_active => shift->max_active);
};

around start => sub {
  my ($orig, $self, $tx, $cb) = @_;
  $self->queue->callback(sub { $self->$orig(@_) })
    unless ($self->queue->callback);
  if ($cb) {
    $tx->on(finish => sub { $self->queue->tx_finish(); });
    $self->queue->on(queue_empty => sub { $self->emit('queue_empty') });
    $self->queue->enqueue([$tx, $cb]);
  }
  else {
    return $orig->($self, $tx);    # Blocking calls skip the queue
  }
};


```
</CodeSurferLayout>

---


I put this in a sub class

Then I converted the sub class to a role

I originally used a recurring timer to process the queue,
this required more code to cleanup the timer.
I changed this to an event (finish) on the transaction

---
Bug 1:
   \_process

---
Make it private
---
Bug 2:

 self-closure

---

Bug 3:

 state = singleton

---

# Mojolicious is an awesome web framework

---

Targeting the Real time web

---

# Real time web == Websockets

---

# Async IO and Event Loop

A way to scale handling HTTP connections faster

- Nginx vs. Apache
- node.js

---

Network IO time vs. CPU time

---

Loop:
  * Check Timers
  * Check IO Handles (Sockets)
  * Run code listening for any new event
  * Loop

---

Mojolicious comes with a bunch of stuff, including an HTTP implementation (server + client).

This makes it easy to write tests without mocking

---

<CodeSurferLayout>

```perl 2,3:4,5[13:25] title="Test::Mojo"

use Test::Mojo;
my $t = Test::Mojo->new('MyApp');
$t->get_ok('/welcome')
  ->status_is(200)
  ->text_is('div#message' => 'Hello!');
---
* > this is what?
2 >
3:4 > makes an HTTP request
5 > assertions on DOM nodes via CSS selectors 
```

</CodeSurferLayout>

---
# User Agent
---

<CodeSurferLayout>

```perl title="Mojo::UserAgent"
# Scrape the latest headlines from a news site
say $ua->get('blogs.perl.org')
  ->result->dom->find('h2 > a')->map('text')->join("\n");
```

<Notes>
This is a note
</Notes>

```perl subtitle="non-blocking"
# Non-blocking request
$ua->get('mojolicious.org' => sub {
  my ($ua, $tx) = @_;
  say $tx->result->dom->at('title')->text;
});
Mojo::IOLoop->start unless Mojo::IOLoop->is_running;
```

```perl subtitle="promises!"
# Concurrent non-blocking requests (synchronized with promises)
my $mojo = $ua->get_p('mojolicious.org');
my $cpan = $ua->get_p('cpan.org');
Mojo::Promise->all($mojo, $cpan)->then(sub {
  my ($mojo, $cpan) = @_;
  say $mojo->[0]->result->dom->at('title')->text;
  say $cpan->[0]->result->dom->at('title')->text;
})->wait;
```

</CodeSurferLayout>

---

A Mojolicious web app is extendable via plugins

---

But many developers want to extend other useful classes in the Mojolicious framework

---

Test::Mojo (the testing library) is one class many developers wanted to extend, in different ways

---

The common way to extend a class is to inherit from it

---

But then you aren't using the same class everyone else, you're using your own (sub)class,
and can't share code with other useful (sub)classes.

---

# Enter: Roles

---

Starting with Mojolicious version 7.41 (August 2017), all classes in the Mojolicious framework got Role support (via Role::Tiny).

---

What are roles?

 - dynamic multiple inheritance
 - also known as traits, mixins
 - create an object or class using a base class, and one or more roles
 - when combining different roles, any class can add new methods or override methods in the base class
 - *Role::Tiny* will give an error if two different roles have methods with the same name
 - *Class::Method::Modifiers* lets us wrap a method in the base class in such a way that multiple overrides can co-exist

---

<Notes>Example of generic code</Notes>


